# P0001R0D1:  Objective-C++ Re:coded (Title Tentative,) Revision 0, Draft 2

<table style="float:left">
  <tr>
    <th style="text-align:left">Date:  </th>
    <td style="text-align:right">Saturday, April 11<sup>th</sup>, 2020</td>
  </tr>
  <tr>
    <th style="text-align:left">Author:  </th>
    <td style="text-align:right"><a href=“https://github.com/RandomDSdevel”>Bryce Glover</a></td>
  </tr>
</table>

## Document History

**R0D0** (Revision 0, Draft 1; Wednesday, November 23<sup>rd</sup>, 2016:)

 - Initial revision.  (🎉!!)  

**R0D1** (Revision 0, Draft 2; Saturday, April 11<sup>th</sup>, 2020:)  

 - Added this 'Document History' section.  
 - Introduction:  
   - Toned it down, make it sound less stuffy and formal and more pragmatic.  
   - Rephrased a few points slightly/somewhat.  
   - Slightly refactored its sentence giving a couple usage examples for Objective-C++.  
   - Removed a reference to the current draft state of this 'proposal.'  
   - Gave the section a mid-level bit of general reorganization.  
 - 'Motivation' section:  
   - Merged it with the introduction.  
 - Resulting 'Intoduction and Motivation' section:  
   - Renamed it to 'Introduction, Motivation, and Problem Statment and Description' to better reflect its intent despite this being a longer (and slightly unwieldy) title.  
 - Added the following sections:  
  - 'Reference Material'
  - 'Prior Art, Similar/Related Work, and Possible Sources of Inspiration' (Though this is currently still just a plcaeholder in this revision.)  
 - Introduced some link placeholders I'll fill in later.  

## Introduction, Motivation, and Problem Statement and Description

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C++–Objective-C interoperability is useful when, for example, programmers wish to write programs which make use of both C++ libraries like that language’s standard library and Objective-C libraries and frameworks like Cocoa.  Interoperability between code written in the two languages, however, remains _quite_ awkward.  [The ‘Objective-C++’ language extensions for C++][1] currently don't do anything to unify the two languages' features' semantics and therefore retain several limitations.  These are that:  

 - C++ and Objective-C classes can't derive from each other.  
 - C++ namespaces can't be declared inside Objective-C declarations.  
 - Similarly, Objective-C declarations may appear only in the global scope, not within a C++ namespace.  
 - C++ namespaces can't be declared within Objective-C classes.  
 - Additionally, Objective-C lacks any notion of nested namespaces.  
 - Objective-C classes can't have member instance (non-'`static`') variables of a C++ class type that:  

   - lacks a default constructor or
   - have one or more '`virtual`' member functions.  

  _Pointers_ to objects of C++ type _can_, however, be used as member instance variables of Objective-C classes without restriction.  (One could, for example, allocate said pointers' target objects using '`::operator new`' from within their enclosing Objective-C classes' '`-init`' method.  Those unfamiliar with Objective-C should note that a [hyphen-minus](https://en.wikipedia.org/wiki/Hyphen-minus) preceding a method name indicates that it's an instance, or non-'`static`,' member function; similarly, plus signs indicate class, or '`static`,' methods.)  
 - Objective-C classes, only being accessible through pointers, can't benefit from C++ value semantics.  
 - Objective-C declarations cannot live within C++ template declarations; similarly, C++ template declarations can't contain Objective-C declarations.  Objective-C types _may_, however, serve as C++ template arguments.  
 - C++ template parameters can also see use as [receivers][Receivers] or arguments, but _not_ as [selectors][Selectors], inside Objective-C [messaging][Message Passing] expressions.  
 - C++ and Objective-C exception handling remains distinct; neither language can catch objects of the other language's exception type.  Some Objective-C(++) run-time libraries mitigate this problem somewhat:  Apple's official one outright replaces Objective-C exceptions wholesale with C++ ones, at least internally, and the GNUstep Objective-C run-time library similarly does a partial replacement of the former with the latter when linked.  
 - Under the old 32-bit Objective-C run-time, one should take care in noting that the destructor calling conventions for/in Objective-C's and C++'s exception run-time models don't match.  In this case, a C++ object's destructor will not be called when an Objective-C exception exits its parent scope.  The modern, 64-bit run-time fixes this issue.  
 - Finally, Objective-C ['blocks'][Blocks] and C++11 lambda expressions remain distinct.  Apple's Objective-C run-time library on Darwin platforms, however, transparently generates a block for any lambda passed where a block is expected.  

## Prior Art, Similar/Related Work, and Possible Sources of Inspiration

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TBD

## Proposal

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TBD

## Detailed Design

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TBD

## Alternatives Considered

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TBD

## Reference Material

[1]:  <https://en.wikipedia.org/wiki/Objective-C#Objective-C.2B.2B> "Objective-C § Objective-C++ — Wikipedia"
[2]:  <http://web.archive.org/web/20100831154014/https://developer.apple.com/mac/library/documentation/Cocoa/Conceptual/ObjectiveC/Articles/ocCPlusPlus.html> "Using C++ With Objective-C — Apple Developer (The Internet Archive) (Originally retrived at 15:40:14 UTC on August 31<sup>st</sup>, 2010)"
<!--Add links to Apple developer or other documentation on the following Objective-C topics:  -->
[Receivers]:  <> ""
[Selectors]:  <> ""
[Message Passing]:  <> ""
[Blocks]:  <> ""
